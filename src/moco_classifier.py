import os
import gc
import numpy as np
import pandas as pd
from sklearn.model_selection import StratifiedKFold
import lightgbm as lgb
from classifier_type import ClassifierType
from clf_util import fast_auc, eval_auc, predict_chunk
from save_log import stop_watch


class MocoClassifier():
    def __init__(self, classifier_type, params, valids, dataset_name):
        os.environ['KMP_DUPLICATE_LIB_OK'] = "True"
        self.classifier_type = classifier_type
        self.params = params
        self.valids = valids
        self.dataset_name = dataset_name

    @stop_watch("MocoClassifier.train()")
    def train(self, train_df):
        clfs = self.__train_as_classifier_type(train_df)
        importances = "Please calculate importances of features"
        self.__save_importances(importances)
        self.clfs = clfs

    @stop_watch("MocoClassifier.predict()")
    def predict(self, test_df):
        if self.classifier_type == ClassifierType.LGBM:
            return self.__predict_with_lgbm(test_df)
        elif self.classifier_type == ClassifierType.CAT_BOOST:
            return self.__predict_with_cat_boost(test_df)

    def __train_as_classifier_type(self, feature_names):
        if self.classifier_type == ClassifierType.LGBM:
            return self.__train_with_lgbm(feature_names)
        elif self.classifier_type == ClassifierType.CAT_BOOST:
            return self.__train_with_cat_boost(feature_names)

    def __train_with_lgbm(self, feature_names):
        print(self.params)
        print(feature_names)
        assert False
        clfs = []
        # y = df["HasDetections"].astype(np.int8)
        # del df["MachineIdentifier"], df["HasDetections"]
        importances = pd.DataFrame()
        # oof_preds = np.zeros((len(df), np.unique(y).shape[0]))
        mtd_params = self.params["mtd_params"]
        trn_params = self.params["trn_params"]
        lgb_params = {
            "objective": "binary",
            "boosting": trn_params["boosting"],
            "metric": trn_params["metric"],
            "n_estimators": trn_params["n_estimators"],
            "learning_rate": trn_params["learning_rate"],
            "num_leaves": trn_params["num_leaves"],
            "n_jobs": -1,
            "seed": 1116,
            "max_depth": trn_params["max_depth"],
            "min_child_samples": trn_params["min_child_samples"],
            "verbosity": -1
        }

        sfk = StratifiedKFold(n_splits=5, shuffle=True, random_state=1116)
        """
        for fold_, (trn_, val_) in enumerate(sfk.split(y, y)):
            print("\t >> {} folds start".format(fold_ + 1))
            trn_x, trn_y = df.iloc[trn_], y.iloc[trn_]
            val_x, val_y = df.iloc[val_], y.iloc[val_]
            train_dataset = lgb.Dataset(trn_x, trn_y)
            valid_dataset = lgb.Dataset(val_x, val_y)
            clf = lgb.train(lgb_params,
                            train_dataset,
                            mtd_params["num_boost_round"],
                            valid_sets=valid_dataset,
                            verbose_eval=mtd_params["verbose_eval"],
                            early_stopping_rounds=mtd_params["early_stopping_rounds"])
            del train_dataset, valid_dataset
            y_pred_valid = clf.predict(val_x, num_iteration=clf.best_iteration)
            del val_x
            gc.collect()
        """

        assert False
        return clfs

    def __predict_with_lgbm(self, df):
        submit = "Please predict df with self.clf"
        return submit

    def __train_with_cat_boost(self, df):
        clf = "Please define cat boost functions"
        return clf

    def __predict_with_cat_boost(self, df):
        submit = "Please predict df with self.clf"
        return submit

    def __save_importances(self, importances):
        """
        # TODO: Implementation of CSV
        mean_gain = importances_[['gain', 'feature']].groupby('feature').mean()
        importances_['mean_gain'] = importances_['feature'].map(mean_gain['gain'])
        plt.figure(figsize=(16, 24))
        sns.barplot(x='gain', y='feature',
                    data=importances_.sort_values('mean_gain', ascending=False))
        plt.tight_layout()
        plt.savefig(Path(__file__).absolute().parents[3] / "data" /
                    "importances" / "{}.png".format(version))
        """
        pass
