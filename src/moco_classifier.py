import os
import numpy as np
import pandas as pd
from sklearn.model_selection import StratifiedKFold
import lightgbm as lgb
from classifier_type import ClassifierType
from save_log import stop_watch


class MocoClassifier():
    def __init__(self, classifier_type, params):
        os.environ['KMP_DUPLICATE_LIB_OK'] = "True"
        self.classifier_type = classifier_type
        self.params = params

    @stop_watch("MocoClassifier.fit()")
    def fit(self, train_df):
        clfs = self.__fit_as_classifier_type(train_df)
        importances = "Please calculate importances of features"
        self.__save_importances(importances)
        self.clfs = clfs

    @stop_watch("MocoClassifier.predict()")
    def predict(self, test_df):
        if self.classifier_type == ClassifierType.LGBM:
            return self.__predict_with_lgbm(test_df)
        elif self.classifier_type == ClassifierType.CAT_BOOST:
            return self.__predict_with_cat_boost(test_df)

    def __fit_as_classifier_type(self, df):
        if self.classifier_type == ClassifierType.LGBM:
            return self.__fit_with_lgbm(df)
        elif self.classifier_type == ClassifierType.CAT_BOOST:
            return self.__fit_with_cat_boost(df)

    def __fit_with_lgbm(self, df):
        print(self.params)
        clfs = []
        y = df["HasDetections"].astype(np.int8)
        del df["MachineIdentifier"], df["HasDetections"]
        importances = pd.DataFrame()
        oof_preds = np.zeros((len(df), np.unique(y).shape[0]))
        mtd_params = self.params["mtd_params"]
        trn_params = self.params["trn_params"]
        lgb_params = {
            "objective": trn_params["objective"],
            "device": trn_params["device"],
            "metric": trn_params["metric"],
            "learning_rate": trn_params["learning_rate"],
            "boosting_type": "gbdt",
            "n_jobs": -1,
            "max_depth": 6,
            "n_estimators": 4000,
            "num_leaves": 20,
            "verbosity": -1,
            "min_child_samples": 200,
            "seed": 1116
        }

        sfk = StratifiedKFold(n_splits=5, shuffle=True, random_state=1116)
        for fold_, (trn_, val_) in enumerate(sfk.split(y, y)):
            print("\t >> {} folds start".format(fold_ + 1))
            trn_x, trn_y = df.iloc[trn_], y.iloc[trn_]
            val_x, val_y = df.iloc[val_], y.iloc[val_]
            train_dataset = lgb.Dataset(trn_x, trn_y)
            valid_dataset = lgb.Dataset(val_x, val_y)
            clf = lgb.train(lgb_params,
                            train_dataset,
                            mtd_params["num_boost_round"],
                            valid_sets=valid_dataset,
                            verbose_eval=mtd_params["verbose_eval"],
                            early_stopping_rounds=mtd_params["early_stopping_rounds"])

        assert False
        return clfs

    def __predict_with_lgbm(self, df):
        submit = "Please predict df with self.clf"
        return submit

    def __fit_with_cat_boost(self, df):
        clf = "Please define cat boost functions"
        return clf

    def __predict_with_cat_boost(self, df):
        submit = "Please predict df with self.clf"
        return submit

    def __save_importances(self, importances):
        """
        # TODO: Implementation of CSV
        mean_gain = importances_[['gain', 'feature']].groupby('feature').mean()
        importances_['mean_gain'] = importances_['feature'].map(mean_gain['gain'])
        plt.figure(figsize=(16, 24))
        sns.barplot(x='gain', y='feature',
                    data=importances_.sort_values('mean_gain', ascending=False))
        plt.tight_layout()
        plt.savefig(Path(__file__).absolute().parents[3] / "data" /
                    "importances" / "{}.png".format(version))
        """
        pass
