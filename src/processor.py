from classifier_type import ClassifierType
from clf_util import model_exist
from feature_extractor import FeatureExtractor
from classifier.lgbm_classifier import LGBMClassifier
from classifier.lgbm_optuna_classifier import LGBMOptunaClassifier
from classifier.catboost_classifier import CATClassifier
from classifier.pytorch_classifier import PyTorchClassifier
from classifier.lgbm_optuna_one_classifier import LGBMOptunaOneClassifier
from save_log import stop_watch, need_prediction, only_prediction


class Processor():
    """
    For processing train and test
    """
    def __init__(self, feature_groups,
                 clf_type, clf_params, dataset_path):
        """
        Parameters
        feature_groups  <dict>      : features dictionary in json
        clf_type        <object>    : classifier type in json
        clf_params      <dict>      : classifier parameters in json
        dataset_path    <PosixPath> : input csv file path in json
        """
        self.feature_groups = feature_groups
        self.dataset_path = dataset_path
        if clf_type == ClassifierType.LGBM:
            self.classifier = LGBMClassifier(clf_params, dataset_name=dataset_path.name)
        elif clf_type == ClassifierType.CAT_BOOST:
            self.classifier = CATClassifier(clf_params, dataset_name=dataset_path.name)
        elif clf_type == ClassifierType.LGBM_OPTUNA:
            self.classifier = LGBMOptunaClassifier(clf_params, dataset_name=dataset_path.name)
        elif clf_type == ClassifierType.PYTORCH:
            self.classifier = PyTorchClassifier(clf_params, dataset_name=dataset_path.name)
        elif clf_type == ClassifierType.LGBM_OPTUNA_ONE:
            self.classifier = LGBMOptunaOneClassifier(clf_params, dataset_name=dataset_path.name)

    def process(self):
        """
        (WIP)
        For processing train and test
            preprocess > train > predict
        """
        feature_names = self.__preprocess()
        validity = None if only_prediction() and model_exist() else self.__train(feature_names)
        predict = self.__predict(feature_names) if need_prediction() or only_prediction() else None
        return validity, predict

    @stop_watch("Processor.preprocess()")
    def __preprocess(self):
        feature_extractor = FeatureExtractor(self.dataset_path, self.feature_groups)
        for valid_dir in ["valid{}".format(str(n)) for n in range(5)]:
            print("\t\t=== {} : {:^10} ===".format(valid_dir, "train"))
            feature_extractor.extract(part="train", valid_dir=valid_dir)
            print("\t\t=== {} : {:^10} ===".format(valid_dir, "validate"))
            feature_extractor.extract(part="validate", valid_dir=valid_dir)
            if need_prediction() or only_prediction():
                print("\t\t=== {} : {:^10} ===".format(valid_dir, "test"))
                feature_extractor.extract(part="test", valid_dir=valid_dir)
        return feature_extractor.get_feature_names()

    @stop_watch("Processor.train()")
    def __train(self, feature_names):
        """
        Processing of train
        1. Feature Extraction
        2. Fitting train data with lgbm
        ---
        Return
        validation output of this process
        """
        return self.classifier.train(feature_names)

    @stop_watch("Processor.predict()")
    def __predict(self, feature_names):
        """
        (WIP)
        Processing of test
        1. Feature Extraction
        2. Predict test data with classifier obtained from process_train()
        """
        submit = self.classifier.predict(feature_names)
        return submit
