from pathlib import Path
import numpy as np
from numba import jit
from logging import getLogger
from save_log import get_version, send_message


# fast roc_auc computation: https://www.kaggle.com/c/microsoft-malware-prediction/discussion/76013
@jit
def fast_auc(y_true, y_prob):
    y_true = np.asarray(y_true)
    y_true = y_true[np.argsort(y_prob)]
    nfalse = 0
    auc = 0
    n = len(y_true)
    for i in range(n):
        y_i = y_true[i]
        nfalse += (1 - y_i)
        auc += y_i * nfalse
    div = nfalse * (n - nfalse)
    if div != 0.0:
        auc /= (nfalse * (n - nfalse))
    else:
        auc = 0.0
    return auc


def eval_auc(preds, dtrain):
    labels = dtrain.get_label()
    return 'auc', fast_auc(labels, preds), True


# idea from this kernel: https://www.kaggle.com/fabiendaniel/detecting-malwares-with-lgbm
def predict_chunk(model, test):
    initial_idx = 0
    chunk_size = 1000000
    current_pred = np.zeros(len(test))
    while initial_idx < test.shape[0]:
        final_idx = min(initial_idx + chunk_size, test.shape[0])
        idx = range(initial_idx, final_idx)
        current_pred[idx] = model.predict(test.iloc[idx], num_iteration=model.best_iteration)
        initial_idx = final_idx
    return current_pred


def output_cv(validity, stamp):
    validity = validity.reset_index()
    columns_order = ["MachineIdentifier", "HasDetections", "Predict"]
    validity = validity.sort_values("MachineIdentifier").reset_index(drop=True).loc[:, columns_order]
    cv_auc = (fast_auc(validity["HasDetections"], np.array(validity["Predict"])))
    getLogger(get_version()).info("\t >> CV Score (AUC):{}".format(cv_auc))
    send_message("\t {} CV Score (AUC):{}".format(stamp, cv_auc))
    return validity


def save_feature_importance(feature_importance, directory_path):
    feature_importance.set_index("feature", inplace=True)
    feature_importance["median"] = feature_importance.median(axis='columns')
    feature_importance.sort_values("median", ascending=False, inplace=True)
    Path.mkdir(directory_path, exist_ok=True, parents=True)
    feature_importance.to_csv(Path(directory_path / "{}.csv".format(get_version())))


def model_exist():
    model_path = Path(__file__).absolute().parents[1] / "data" / "model" / str(get_version())
    for fold in range(5):
        if Path(model_path / "valid{}.model".format(fold)).exists() is not True:
            return False
    return True
