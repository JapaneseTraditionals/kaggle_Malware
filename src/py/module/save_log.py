# Log modules

import os
import sys
import inspect
from functools import wraps
import time
from pathlib import Path
from logging import getLogger, Formatter, FileHandler, StreamHandler, INFO, DEBUG
import pickle
from lightgbm.callback import _format_eval_result

def create_logger(exp_version, params=None):
    log_file = (Path(__file__).parents[3] / "data" / "log" / (exp_version + ".log")).resolve()

    # init
    __init_logfile(params, log_file)

    # logger
    logger_ = getLogger(exp_version)
    logger_.setLevel(DEBUG)

    # formatter
    fmr = Formatter("[%(levelname)s] %(asctime)s >>\t%(message)s")

    # file handler
    fh = FileHandler(log_file)
    fh.setLevel(DEBUG)
    fh.setFormatter(fmr)
    # stream handler
    ch = StreamHandler()
    ch.setLevel(INFO)
    ch.setFormatter(fmr)

    logger_.addHandler(fh)
    logger_.addHandler(ch)


def get_logger(exp_version):
    return getLogger(exp_version)


def __init_logfile(params, log_file):
    with open(log_file, "w") as f:
        if params is not None:
            f.write(params)
        else:
            pass

def lgbm_logger(VERSION, level=DEBUG, period=1, show_stdv=True):
    def _callback(env):
        if period > 0 and env.evaluation_result_list and (env.iteration + 1) % period == 0:
            result = '\t'.join([_format_eval_result(x, show_stdv) for x in env.evaluation_result_list])
            get_logger(VERSION).log(level, "[%d]\t%s" % (env.iteration + 1, result))
    _callback.order = 10
    return _callback


def lgbm_pickle(VERSION=None, clfs=None):
    with open(Path(__file__).absolute().parents[3] / "model" / "{}.pickle".format(VERSION), mode="wb") as f:
        pickle.dump(clfs, f)
        print("\t==   save model   ==")

def stop_watch(*dargs, **dkargs):
    def decorator(func):
        @wraps(func)
        def wrapper(*args, **kargs):
            method_name = dargs[0]
            index = dargs[1]
            version = inspect.currentframe().f_back.f_back
            if index != 0:
                for _ in range(index+2):
                    version = version.f_back
            version = os.path.splitext(version.f_code.co_filename)[0][-4:]
            start = time.time()
            getLogger(version).info("{}".format(method_name))
            result = func(*args, **kargs)
            elapsed_time = int(time.time() - start)
            minits, sec = divmod(elapsed_time, 60)
            hour, minits = divmod(minits, 60)
            getLogger(version).info("{}: [elapsed_time]\t>> {:0>2}:{:0>2}:{:0>2}".format(method_name, hour, minits, sec))
            return result
        return wrapper
    return decorator
