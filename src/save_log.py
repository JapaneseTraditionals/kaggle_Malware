# Log modules
from functools import wraps
from get_option import get_option
import time
from pathlib import Path
from logging import getLogger, Formatter, FileHandler, StreamHandler
from logging import INFO, DEBUG
import pickle
from lightgbm.callback import _format_eval_result


def get_version():
    return get_option().version


def need_prediction():
    return get_option().Predict


def get_recalcFeature():
    recalc_list = None
    if get_option().reCalculation is not None:
        with Path(get_option().reCalculation).open() as f:
            recalc_list = f.readline().rstrip("\r\n").split(",")
    return recalc_list


def get_njobs():
    return get_option().nJobs


def create_logger(exp_version, params=None):
    log_file = (Path(__file__).parents[1] / "log" /
                (exp_version + ".log")).resolve()

    # init
    __init_logfile(params, log_file)

    # logger
    logger_ = getLogger(exp_version)
    logger_.setLevel(DEBUG)

    # formatter
    fmr = Formatter("[%(levelname)s] %(asctime)s >>\t%(message)s")

    # file handler
    fh = FileHandler(log_file)
    fh.setLevel(DEBUG)
    fh.setFormatter(fmr)
    # stream handler
    ch = StreamHandler()
    ch.setLevel(INFO)
    ch.setFormatter(fmr)

    logger_.addHandler(fh)
    logger_.addHandler(ch)


def __init_logfile(params, log_file):
    with open(log_file, "w") as f:
        if params is not None:
            f.write(params)
        else:
            pass


def lgbm_logger(VERSION, level=DEBUG, period=1, show_stdv=True):
    def _callback(env):
        if period > 0 and env.evaluation_result_list and (env.iteration + 1) % period == 0:
            result = '\t'.join([_format_eval_result(x, show_stdv) for x in env.evaluation_result_list])
            getLogger(VERSION).log(level, "[%d]\t%s" % (env.iteration + 1, result))
    _callback.order = 10
    return _callback


def lgbm_pickle(VERSION=None, clfs=None):
    with open(Path(__file__).absolute().parents[3] / "model" / "{}.pickle"
              .format(VERSION), mode="wb") as f:
        pickle.dump(clfs, f)
        print("\t==   save model   ==")


def stop_watch(*dargs, **dkargs):
    def decorator(func):
        @wraps(func)
        def wrapper(*args, **kargs):
            version = get_version()
            method_name = dargs[0]
            start = time.time()
            getLogger(version).info("[START]  {}".format(method_name))
            result = func(*args, **kargs)
            elapsed_time = int(time.time() - start)
            minits, sec = divmod(elapsed_time, 60)
            hour, minits = divmod(minits, 60)
            getLogger(version).info(
                "[FINISH] {}: [elapsed_time] >> {:0>2}:{:0>2}:{:0>2}"
                .format(method_name, hour, minits, sec))
            return result
        return wrapper
    return decorator
