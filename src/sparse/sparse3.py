import pandas as pd
import numpy as np
import lightgbm as lgb
import dask.dataframe as dd
from scipy.sparse import vstack, csr_matrix, save_npz, load_npz
from sklearn.preprocessing import LabelEncoder, OneHotEncoder
from sklearn.model_selection import StratifiedKFold
from slackclient import SlackClient
from pathlib import Path
import gc
gc.enable()
ROOT_PATH = Path(".").absolute()

VERSION = str(Path(__file__)).split('/')[-1].split('.')[0]
SUBMIT_FILE = "{}.csv".format(VERSION)

max_observations = 3000
min_threshold_for_unbalanced_values = 0.75
max_threshold_for_unbalanced_values = 0.25
random_state = 16

n_estimators = 30000
learning_rate = 0.1
num_leaves = 128
min_child_samples = 240
colsample_bytree = 0.28
early_stopping_rounds = 1000


usecols = {
    'MachineIdentifier',
    'EngineVersion',
    'AppVersion',
    'AvSigVersion',
    'RtpStateBitfield',
    'IsSxsPassiveMode',
    'DefaultBrowsersIdentifier',
    'AVProductStatesIdentifier',
    'AVProductsInstalled',
    'AVProductsEnabled',
    'CountryIdentifier',
    'CityIdentifier',
    'OrganizationIdentifier',
    'GeoNameIdentifier',
    'LocaleEnglishNameIdentifier',
    'Platform',
    'OsVer',
    'OsBuild',
    'OsSuite',
    'OsBuildLab',
    'IsProtected',
    'SmartScreen',
    'Firewall',
    'Census_DeviceFamily',
    'Census_OEMNameIdentifier',
    'Census_OEMModelIdentifier',
    'Census_ProcessorCoreCount',
    'Census_ProcessorModelIdentifier',
    'Census_ProcessorClass',
    'Census_PrimaryDiskTotalCapacity',
    'Census_PrimaryDiskTypeName',
    'Census_SystemVolumeTotalCapacity',
    'Census_HasOpticalDiskDrive',
    'Census_TotalPhysicalRAM',
    'Census_ChassisTypeName',
    'Census_InternalPrimaryDiagonalDisplaySizeInInches',
    'Census_InternalPrimaryDisplayResolutionHorizontal',
    'Census_InternalPrimaryDisplayResolutionVertical',
    'Census_PowerPlatformRoleName',
    'Census_InternalBatteryType',
    'Census_InternalBatteryNumberOfCharges',
    'Census_OSVersion',
    'Census_OSArchitecture',
    'Census_OSBranch',
    'Census_OSBuildNumber',
    'Census_OSBuildRevision',
    'Census_OSEdition',
    'Census_OSSkuName',
    'Census_OSInstallTypeName',
    'Census_OSInstallLanguageIdentifier',
    'Census_OSUILocaleIdentifier',
    'Census_OSWUAutoUpdateOptionsName',
    'Census_GenuineStateName',
    'Census_ActivationChannel',
    'Census_FlightRing',
    'Census_ThresholdOptIn',
    'Census_FirmwareManufacturerIdentifier',
    'Census_FirmwareVersionIdentifier',
    'Census_IsSecureBootEnabled',
    'Census_IsVirtualDevice',
    'Census_IsTouchEnabled',
    'Census_IsAlwaysOnAlwaysConnectedCapable',
    'Wdft_IsGamer',
    'Wdft_RegionIdentifier'
}

dtypes = {
    'MachineIdentifier'                                 : 'object',
    'EngineVersion'                                     : 'object',
    'AppVersion'                                        : 'object',
    'AvSigVersion'                                      : 'object',
    'RtpStateBitfield'                                  : 'float16',
    'IsSxsPassiveMode'                                  : 'int8',
    'DefaultBrowsersIdentifier'                         : 'float32',
    'AVProductStatesIdentifier'                         : 'float32',
    'AVProductsInstalled'                               : 'float16',
    'AVProductsEnabled'                                 : 'float16',
    'CountryIdentifier'                                 : 'int16',
    'CityIdentifier'                                    : 'float32',
    'OrganizationIdentifier'                            : 'float16',
    'GeoNameIdentifier'                                 : 'float16',
    'LocaleEnglishNameIdentifier'                       : 'int16',
    'Platform'                                          : 'object',
    'OsVer'                                             : 'object',
    'OsBuild'                                           : 'int16',
    'OsSuite'                                           : 'int16',
    'OsBuildLab'                                        : 'object',
    'IsProtected'                                       : 'float16',
    'SmartScreen'                                       : 'object',
    'Firewall'                                          : 'float16',
    'Census_DeviceFamily'                               : 'object',
    'Census_OEMNameIdentifier'                          : 'float32',
    'Census_OEMModelIdentifier'                         : 'float32',
    'Census_ProcessorCoreCount'                         : 'float16',
    'Census_ProcessorModelIdentifier'                   : 'float32',
    'Census_ProcessorClass'                             : 'object',
    'Census_PrimaryDiskTotalCapacity'                   : 'float64',
    'Census_PrimaryDiskTypeName'                        : 'object',
    'Census_SystemVolumeTotalCapacity'                  : 'float64',
    'Census_HasOpticalDiskDrive'                        : 'int8',
    'Census_TotalPhysicalRAM'                           : 'float32',
    'Census_ChassisTypeName'                            : 'object',
    'Census_InternalPrimaryDiagonalDisplaySizeInInches' : 'float32',
    'Census_InternalPrimaryDisplayResolutionHorizontal' : 'float32',
    'Census_InternalPrimaryDisplayResolutionVertical'   : 'float32',
    'Census_PowerPlatformRoleName'                      : 'object',
    'Census_InternalBatteryType'                        : 'object',
    'Census_InternalBatteryNumberOfCharges'             : 'float64',
    'Census_OSVersion'                                  : 'object',
    'Census_OSArchitecture'                             : 'object',
    'Census_OSBranch'                                   : 'object',
    'Census_OSBuildNumber'                              : 'int16',
    'Census_OSBuildRevision'                            : 'int32',
    'Census_OSEdition'                                  : 'object',
    'Census_OSSkuName'                                  : 'object',
    'Census_OSInstallTypeName'                          : 'object',
    'Census_OSInstallLanguageIdentifier'                : 'float16',
    'Census_OSUILocaleIdentifier'                       : 'int16',
    'Census_OSWUAutoUpdateOptionsName'                  : 'object',
    'Census_GenuineStateName'                           : 'object',
    'Census_ActivationChannel'                          : 'object',
    'Census_FlightRing'                                 : 'object',
    'Census_ThresholdOptIn'                             : 'float16',
    'Census_FirmwareManufacturerIdentifier'             : 'float16',
    'Census_FirmwareVersionIdentifier'                  : 'float32',
    'Census_IsSecureBootEnabled'                        : 'int8',
    'Census_IsVirtualDevice'                            : 'float16',
    'Census_IsTouchEnabled'                             : 'int8',
    'Census_IsAlwaysOnAlwaysConnectedCapable'           : 'float16',
    'Wdft_IsGamer'                                      : 'float16',
    'Wdft_RegionIdentifier'                             : 'float16',
    'HasDetections'                                     : 'int8'
}


def read_token(token_path):
    token = ""
    if token_path.exists() is not True:
        return None
    with open(token_path, 'r') as f:
        token = f.read()
    token = token.replace('\n', '')
    return token


CHANNEL = "log"
TOKEN_FILE = ".slack_token"
TOKEN_PATH = Path(__file__).absolute().parents[2] / TOKEN_FILE

token = read_token(TOKEN_PATH)
client = SlackClient(token)


def send_message(text):
    text = "[{}]: {}".format(SUBMIT_FILE, text)
    client.api_call(
        "chat.postMessage",
        channel=CHANNEL,
        text=text
    )


send_message("Reading test.csv")
print("Reading test.csv")
test_df = dd.read_csv(ROOT_PATH / "input" / "test.csv", dtype=dtypes, usecols=usecols).compute()
test_df['MachineIdentifier'] = test_df.index.astype('uint32')
usecols.add("HasDetections")

send_message("Reading train.csv")
print("Reading train.csv")
train_df = dd.read_csv(ROOT_PATH / "input" / "train.csv", dtype=dtypes, usecols=usecols).compute()
train_df['MachineIdentifier'] = train_df.index.astype('uint32')

send_message("Creating sparse features...")
print("Creating sparse features...")
for usecol in train_df.columns.tolist()[1:-1]:
    print(usecol)
    train_df[usecol] = train_df[usecol].astype('str')
    test_df[usecol] = test_df[usecol].astype('str')

    # Fit LabelEncoder
    label_encoder = LabelEncoder().fit(
        np.unique(train_df[usecol].unique().tolist() + test_df[usecol].unique().tolist()))
    train_df[usecol] = label_encoder.transform(train_df[usecol]) + 1
    test_df[usecol] = label_encoder.transform(test_df[usecol]) + 1

    agg_train = (train_df
                 .groupby([usecol])
                 .aggregate({'MachineIdentifier': 'count'})
                 .reset_index()
                 .rename({'MachineIdentifier': 'Train'}, axis=1))
    agg_test = (test_df
                .groupby([usecol])
                .aggregate({'MachineIdentifier': 'count'})
                .reset_index()
                .rename({'MachineIdentifier': 'Test'}, axis=1))

    agg = pd.merge(agg_train, agg_test, on=usecol, how='outer').replace(np.nan, 0)
    # Select values with more than 1000 observations
    agg = agg[(agg['Train'] > max_observations)].reset_index(drop=True)
    agg['Total'] = agg['Train'] + agg['Test']

    # Drop unbalanced values
    agg = agg[(agg['Train'] / agg['Total'] > min_threshold_for_unbalanced_values) & (agg['Train'] / agg['Total'] < max_threshold_for_unbalanced_values)]
    agg[usecol + 'Copy'] = agg[usecol]

    train_df[usecol] = (pd.merge(train_df[[usecol]],
                                 agg[[usecol, usecol + 'Copy']],
                                 on=usecol, how='left')[usecol + 'Copy']
                        .replace(np.nan, 0).astype('int').astype('category'))

    test_df[usecol] = (pd.merge(test_df[[usecol]],
                                agg[[usecol, usecol + 'Copy']],
                                on=usecol, how='left')[usecol + 'Copy']
                       .replace(np.nan, 0).astype('int').astype('category'))
    del label_encoder, agg_train, agg_test, agg, usecol
    gc.collect()

y_train = np.array(train_df['HasDetections'])
train_ids = train_df.index
test_ids = test_df.index

del train_df['HasDetections'], train_df["MachineIdentifier"], test_df["MachineIdentifier"]
gc.collect()

# Fit OneHotEncoder
send_message("Fitting OneHotEncoder")
print("Fitting OneHotEncoder")
ohe = OneHotEncoder(sparse=True, dtype='uint8').fit(train_df)


# Transform data using small groups to reduce memory usage
send_message("Transforming data")
print("Transforming data")
m = 100000
train_df = vstack([ohe.transform(train_df[i * m:(i + 1) * m]) for i in range(train_df.shape[0] // m + 1)])
test_df = vstack([ohe.transform(test_df[i * m:(i + 1) * m]) for i in range(test_df.shape[0] // m + 1)])
save_npz(str(ROOT_PATH / 'tmp' / 'train.npz'), train_df, compressed=True)
save_npz(str(ROOT_PATH / 'tmp' / 'test.npz'), test_df, compressed=True)

del ohe, train_df, test_df
gc.collect()

skf = StratifiedKFold(n_splits=5, shuffle=True, random_state=random_state)
skf.get_n_splits(train_ids, y_train)

lgb_test_result = np.zeros(test_ids.shape[0])
counter = 0


send_message("Training data...")
print("Training data..")
for train_index, test_index in skf.split(train_ids, y_train):

    send_message('\t Fold {}\n'.format(counter + 1))
    print('\t Fold {}\n'.format(counter + 1))
    train = load_npz(str(ROOT_PATH / 'tmp' / 'train.npz'))
    X_fit = vstack([train[train_index[i * m:(i + 1) * m]] for i in range(train_index.shape[0] // m + 1)])
    X_val = vstack([train[test_index[i * m:(i + 1) * m]] for i in range(test_index.shape[0] // m + 1)])
    X_fit, X_val = csr_matrix(X_fit, dtype='float32'), csr_matrix(X_val, dtype='float32')
    y_fit, y_val = y_train[train_index], y_train[test_index]

    del train
    gc.collect()

    lgb_model = lgb.LGBMClassifier(max_depth=-1,
                                   n_estimators=n_estimators,
                                   learning_rate=learning_rate,
                                   num_leaves=num_leaves,
                                   min_child_samples=min_child_samples,
                                   colsample_bytree=colsample_bytree,
                                   objective='binary',
                                   n_jobs=-1)

    lgb_model.fit(X_fit, y_fit, eval_metric='auc',
                  eval_set=[(X_val, y_val)],
                  verbose=100, early_stopping_rounds=early_stopping_rounds)

    del X_fit, X_val, y_fit, y_val, train_index, test_index
    gc.collect()

    test = load_npz(str(ROOT_PATH / 'tmp' / 'test.npz'))
    test = csr_matrix(test, dtype='float32')
    lgb_test_result += lgb_model.predict_proba(test)[:, 1]
    counter += 1

    del test
    gc.collect()

send_message("Creating the submission csv")
print("Creating the submission csv")
submission = pd.read_csv(ROOT_PATH / "input" / "sample_submission.csv")
submission['HasDetections'] = lgb_test_result / counter
submission.to_csv(ROOT_PATH / "data" / "submit" / SUBMIT_FILE, index=False)

send_message("Done")
print("Done")
