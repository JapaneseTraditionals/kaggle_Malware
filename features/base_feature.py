from abc import ABCMeta, abstractmethod
from pathlib import Path
import gc
import dask.dataframe as dd
from tqdm import tqdm
from features.get_dtype import get_csv_dtype
from exceptions import IrregularArgumentException, IrregularCalcBackException


class BaseFeature(metaclass=ABCMeta):

    def __init__(self, features, input_path, is_train):
        '''
        features    <dict>    : groupごとの各種特徴量名
        input_path  <string>  : 対象データが保存されているディレクトリ
        is_train    <boolean> : True > train, False > test
        '''
        self.features = features
        self.part = "train" if is_train else "test"
        self.subset_name = input_path.split("/")[-1]
        self.input_path = Path(input_path)
        self.output_path = Path(__file__).absolute().parents[1] / "data" / "features" / self.subset_name
        self.output_filename = "{}_{}.csv".format(self.part, self.__class__.__name__)

        self.output_path.mkdir(parents=True, exist_ok=True)

    @abstractmethod
    def extract(self):
        '''
        1. 計算の必要性の確認
        2. 必要であれば計算し保存(pandas base)
        3. 請求されている特徴量のみを呼び出してdataframeで返す(dask.dataframe)
        '''
        def calc_back_checker(calc_back_df, id_set):
            if len(calc_back_df.columns) != 2:
                print("Calc back dataframe columns length need 2.")
                raise IrregularCalcBackException()
            if "MachineIdentifier" not in calc_back_df.columns:
                print("Calc back dataframe columns need \"MachineIdentifier\".")
                raise IrregularCalcBackException()
            if len(set(calc_back_df["MachineIdentifier"].values) ^ id_set) != 0:
                print("Neither too much nor too little \"MachineIdentifier\" need.")
                raise IrregularCalcBackException()

        featuresFromula = self.getFeaureFromulas()
        featureNameList = list(featuresFromula.keys())
        needCalculationFeatures = {fn: featuresFromula[fn] for fn in featureNameList if not self.isCalculated(fn)}

        if len(needCalculationFeatures) > 0:
            part_df = dd.read_csv(self.input_path / "{}.csv".format(self.part),
                                  dtype=get_csv_dtype(),
                                  usecols=list(self.features.keys()) + ["MachineIdentifier"])
            part_df = part_df.compute()

            with tqdm(needCalculationFeatures.items(), ncols=10) as progress:
                for name, formula in progress:
                    progress.set_description("[Group] {:<15} >> processing \"{}\"".format(self.__class__.__name__, name))
                    if len(formula) == 1:
                        new_feature_df = eval(formula[0], locals())
                    elif len(formula) == 2:
                        new_feature_df = eval(formula[0], locals(), formula[1])
                    calc_back_checker(new_feature_df, set(part_df["MachineIdentifier"].values))

                    back_col_name = [n for n in new_feature_df.columns if n != "MachineIdentifier"][0]
                    new_feature_df = new_feature_df.rename(columns={back_col_name: name})

                    self.saveNewFeature(new_feature_df)

                    del new_feature_df
                    gc.collect()

        return dd.read_csv(self.output_path / self.output_filename, usecols=["MachineIdentifier"] + featureNameList)

    def isCalculated(self, feature_name):
        '''
        feature_name = {Group_name}_{attribute_name}
        {part}_{group_name}.csvが存在し，かつcsvの一行目にfeature_nameが確認できた場合にTrueを返す．
        '''
        isCalculated = False
        output_file_path = self.output_path / self.output_filename

        if output_file_path.exists():
            with output_file_path.open() as f:
                columns = f.readline().rstrip("\n\r").split(",")
            if feature_name in columns:
                isCalculated = True

        return isCalculated

    def getFeaureFromulas(self):
        '''
        要求されているfeatureをfeature_nameとfeature_formulaに直してDictで返す．
        return :
            <dict>
            {
            "feature_name1" : [formula1],
            "feature_name2" : [formula2, args],
            "feature_name3" : [formula3, args]
            }
            feature_formula         : "self."calc"(part_df["feature"], arg1, arg2)"
            eval(formula, locals(), args={"arg1": a, "arg2: b"})

            "feature_name"  > 保存先の特徴名 Ex. "feature"_"calc"_a_b etc.
            "calc"          > メソッド名，引数に適応する計算
            "feature"       > inputしたCSV内のcolumn名，（第一引数はpart_df[feature]）
            "args"          > 第二以降の引数を格納した辞書
        '''
        def setFormula(calc, feature, args=None):
            formula = "self." + calc + "(part_df[[\"MachineIdentifier\", \"" + feature
            if args is None:
                formula = formula + "\"]])"
            else:
                formula = formula + "\"]], " + ", ".join([arg for arg in args.keys()]) + ")"
            return formula

        feature_dict = {}

        for feature, calculations in self.features.items():
            for calc, args_list in calculations.items():
                if args_list is None:
                    feature_name = feature + "_" + calc
                    feature_formula = setFormula(calc, feature)
                    feature_dict[feature_name] = [feature_formula]
                elif type(args_list) is list:
                    for args in args_list:
                        feature_name = feature + "_" + calc + "_" + "_".join([arg for arg in args.values()])
                        feature_formula = setFormula(calc, feature, args=args)
                        feature_dict[feature_name] = [feature_formula, args]
                else:
                    raise IrregularArgumentException()
        return feature_dict

    def saveNewFeature(self, new_feature_df):
        '''
        new_feature_df  <pandas.Dataframe>
          columns = [MachineIdentifier, {feature_name}]
          作成した特徴量を受け取りすでに作成している特徴量と合わせてcsvで保存する．
          indexは適当，sortも不要
        '''
        output_file_path = self.output_path / self.output_filename
        if output_file_path.exists():
            feature_df = dd.read_csv(output_file_path)
            feature_df = feature_df.compute()
            feature_df = feature_df.merge(right=new_feature_df,
                                          on="MachineIdentifier",
                                          how="inner",
                                          sort=True)
        else:
            feature_df = new_feature_df
        feature_df.to_csv(output_file_path, index=False)
