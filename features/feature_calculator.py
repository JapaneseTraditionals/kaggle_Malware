import pandas as pd
from sklearn.preprocessing import OneHotEncoder
from exceptions import IrregularCalcBackException


class feature_calculator():
    def __init__(self, part, train_df, validate_df, test_df):
        self.part = part

        feature_cols = test_df.columns.tolist()
        self.train_df = train_df[feature_cols]
        self.validate_df = validate_df[feature_cols]
        self.test_df = test_df

        target_cols = ["MachineIdentifier", "HasDetections"]
        self.target_df = pd.concat([train_df[target_cols], validate_df[target_cols]])

    def calc(self, func, columns, args, encode=None):
        if encode is None:
            df = self.NotSet(func, columns, args)
        elif encode == "LabelEncoding":
            df = self.LabelEncoding(func, columns, args)
        elif encode == "CountEncoding":
            df = self.CountEncoding(func, columns, args)
        elif encode == "RankEncoding":
            df = self.RankEncoding(func, columns, args)
        elif encode == "FactorizeEncoding":
            df = self.FactorizeEncoding(func, columns, args)
        elif encode == "FrequencyEncoding":
            df = self.FrequencyEncoding(func, columns, args)
        elif encode == "TargetEncoding":
            df = self.TargetEncoding(func, columns, args)
        elif encode == "OneHotEncoding":
            df = self.OneHotEncoding(func, columns, args)

        df = df[["MachineIdentifier"] + [c for c in df.columns if c != "MachineIdentifier"]]
        df.sort_values("MachineIdentifier", inplace=True)
        df.reset_index(drop=True, inplace=True)
        return df

    def NotSet(self, func, columns, args):
        part_df = self.__get_part_df()[["MachineIdentifier"] + columns]

        id_set = set(part_df["MachineIdentifier"].values)
        part_df = func(part_df, **args)
        self.__calc_back_checker(part_df, id_set)

        return part_df

    def LabelEncoding(self, func, columns, args):
        full_df = pd.concat([self.train_df, self.validate_df, self.test_df])[["MachineIdentifier"] + columns]

        id_set = set(full_df["MachineIdentifier"].values)
        full_df = func(full_df, **args)
        self.__calc_back_checker(full_df, id_set)

        full_df.sort_values("MachineIdentifier", inplace=True)
        full_df = full_df[["MachineIdentifier"] + [c for c in list(full_df.columns) if c != "MachineIdentifier"]]

        feature_col = [c for c in list(full_df.columns) if c != "MachineIdentifier"][0]
        labels, uniques = pd.factorize(full_df[feature_col])
        full_df[feature_col] = labels

        M_id = self.__get_part_df()["MachineIdentifier"].values.tolist()
        part_df = full_df[full_df["MachineIdentifier"].isin(M_id)]

        return part_df

    def CountEncoding(self, func, columns, args):
        # Make Count Dictionary from train_df
        train_df = self.train_df[["MachineIdentifier"] + columns]

        id_set = set(train_df["MachineIdentifier"].values)
        train_df = func(train_df, **args)
        self.__calc_back_checker(train_df, id_set)

        feature_col = [c for c in list(train_df.columns) if c != "MachineIdentifier"][0]
        count_dict = train_df[feature_col].value_counts(dropna=False).to_dict()

        # Calc feature encode by FrequencyEncoding
        part_df = self.__get_part_df()[["MachineIdentifier"] + columns]

        id_set = set(part_df["MachineIdentifier"].values)
        part_df = func(part_df, **args)
        self.__calc_back_checker(part_df, id_set)

        feature_col = [c for c in list(part_df.columns) if c != "MachineIdentifier"][0]
        part_df[feature_col] = part_df[feature_col].map(count_dict)

        return part_df

    def RankEncoding(self, func, columns, args):
        # Make Rank Dictionary from train_df
        train_df = self.train_df[["MachineIdentifier"] + columns]

        id_set = set(train_df["MachineIdentifier"].values)
        train_df = func(train_df, **args)
        self.__calc_back_checker(train_df, id_set)

        feature_col = [c for c in list(train_df.columns) if c != "MachineIdentifier"][0]
        value_count = train_df[feature_col].value_counts(dropna=False)
        rank_dict = value_count.rank(method="min").to_dict()

        # Calc feature encode by RankEncoding
        part_df = self.__get_part_df()[["MachineIdentifier"] + columns]

        id_set = set(part_df["MachineIdentifier"].values)
        part_df = func(part_df, **args)
        self.__calc_back_checker(part_df, id_set)

        feature_col = [c for c in list(part_df.columns) if c != "MachineIdentifier"][0]
        part_df[feature_col] = part_df[feature_col].map(rank_dict)

        return part_df

    def FactorizeEncoding(self, func, columns, args):
        train_df = self.train_df[["MachineIdentifier"] + columns]

        id_set = set(train_df["MachineIdentifier"].values)
        train_df = func(train_df, **args)
        self.__calc_back_checker(train_df, id_set)

        feature_col = [c for c in list(train_df.columns) if c != "MachineIdentifier"][0]
        labels, uniques = pd.factorize(train_df[feature_col])

        part_df = self.__get_part_df()[["MachineIdentifier"] + columns]

        id_set = set(part_df["MachineIdentifier"].values)
        part_df = func(part_df, **args)
        self.__calc_back_checker(part_df, id_set)

        feature_col = [c for c in list(train_df.columns) if c != "MachineIdentifier"][0]
        part_df[feature_col] = uniques.get_indexer(part_df[feature_col])

        return part_df

    def FrequencyEncoding(self, func, columns, args):
        # Make Frequency Dictionary from train_df
        train_df = self.train_df[["MachineIdentifier"] + columns]

        id_set = set(train_df["MachineIdentifier"].values)
        train_df = func(train_df, **args)
        self.__calc_back_checker(train_df, id_set)

        feature_col = [c for c in list(train_df.columns) if c != "MachineIdentifier"][0]
        freq_dict = train_df[feature_col].value_counts(dropna=False, normalize=True).to_dict()

        # Calc feature encode by FrequencyEncoding
        part_df = self.__get_part_df()[["MachineIdentifier"] + columns]

        id_set = set(part_df["MachineIdentifier"].values)
        part_df = func(part_df, **args)
        self.__calc_back_checker(part_df, id_set)

        feature_col = [c for c in list(part_df.columns) if c != "MachineIdentifier"][0]
        part_df[feature_col] = part_df[feature_col].map(freq_dict)

        return part_df

    def TargetEncoding(self, func, columns, args):
        # Make Target Dictionary from train_df and target_df
        train_df = self.train_df[["MachineIdentifier"] + columns]

        id_set = set(train_df["MachineIdentifier"].values)
        train_df = func(train_df, **args)
        self.__calc_back_checker(train_df, id_set)

        feature_col = [c for c in list(train_df.columns) if c != "MachineIdentifier"][0]
        train_df = train_df.astype(str)

        target_df = self.target_df
        train_df = pd.merge(train_df, target_df, on="MachineIdentifier", how="left")

        target_dict = train_df.groupby(feature_col).mean()["HasDetections"]

        # Calc feature encode by TargetEncoding
        part_df = self.__get_part_df()[["MachineIdentifier"] + columns]

        id_set = set(part_df["MachineIdentifier"].values)
        part_df = func(part_df, **args)
        self.__calc_back_checker(part_df, id_set)

        feature_col = [c for c in list(part_df.columns) if c != "MachineIdentifier"][0]
        part_df[feature_col] = part_df[feature_col].astype(str).map(target_dict)

        return part_df

    def OneHotEncoding(self, func, columns, args):
        # Make OneHotEncoder from train_df
        train_df = self.train_df[["MachineIdentifier"] + columns]

        id_set = set(train_df["MachineIdentifier"].values)
        train_df = func(train_df, **args)
        self.__calc_back_checker(train_df, id_set)

        feature_col = [c for c in list(train_df.columns) if c != "MachineIdentifier"][0]
        enc = OneHotEncoder(sparse=False, handle_unknown="ignore")
        enc.fit(train_df[[feature_col]].astype(str).values)

        # Calc feature encode by OneHotEncoding
        part_df = self.__get_part_df()[["MachineIdentifier"] + columns]

        id_set = set(part_df["MachineIdentifier"].values)
        part_df = func(part_df, **args)
        self.__calc_back_checker(part_df, id_set)

        feature_col = [c for c in list(part_df.columns) if c != "MachineIdentifier"][0]
        ohe_df = pd.DataFrame(enc.transform(part_df[[feature_col]].astype(str).values), columns=enc.get_feature_names(input_features=[""]))

        ohe_df["MachineIdentifier"] = part_df["MachineIdentifier"]
        return ohe_df

    def __get_part_df(self):
        if self.part == "train":
            df = self.train_df
        elif self.part == "validate":
            df = self.validate_df
        elif self.part == "test":
            df = self.test_df
        return df

    def __calc_back_checker(self, calc_back_df, id_set):
        if len(calc_back_df.columns) != 2:
            print("Calc back dataframe columns length need 2.")
            raise IrregularCalcBackException()
        if "MachineIdentifier" not in calc_back_df.columns:
            print("Calc back dataframe columns need \"MachineIdentifier\".")
            raise IrregularCalcBackException()
        if len(set(calc_back_df["MachineIdentifier"].values) ^ id_set) != 0:
            print("Neither too much nor too little \"MachineIdentifier\" need.")
            raise IrregularCalcBackException()
        if len(calc_back_df["MachineIdentifier"]) != len(id_set):
            print("Calc back dataframe has too much index.")
            raise IrregularCalcBackException()
