from abc import ABCMeta, abstractmethod
import gc
import warnings
from pathlib import Path
import pandas as pd
import dask.dataframe as dd
import fasteners
from joblib import Parallel, delayed
from features.get_dtype import get_csv_dtype
from exceptions import IrregularArgumentException, IrregularCalcBackException
warnings.filterwarnings('ignore')


class BaseFeature_multi(metaclass=ABCMeta):

    def __init__(self, features, input_path, output_path):
        '''
        features    <dict>   : groupごとの各種特徴量名
        input_path  <string> : 対象データが保存されているディレクトリ
        output_path <string> : True > train, False > test
        '''
        self.features = features
        self.input_path = input_path
        self.output_path = output_path
        self.valid_dir = output_path.parent.name
        self.dataset_path = input_path.parent if input_path.name == "test.csv" else input_path.parents[1]
        self.lock = fasteners.InterProcessLock('tmp/tmp_lock_file')

        self.output_path.parent.mkdir(parents=True, exist_ok=True)

    @abstractmethod
    def get_loadcols(self):
        """
        return
            : columns list
        """
        pass

    @abstractmethod
    def extract(self):
        '''
        1. 計算の必要性の確認
        2. 必要であれば計算し保存(pandas base)
        3. 展開した特徴量をlistで返す
        '''
        def calcFratures(name, formula):
            part_df = pd.read_csv(self.input_path,
                                  dtype=get_csv_dtype(),
                                  usecols=["MachineIdentifier"] + self.get_loadcols())
            if len(formula) == 1:
                new_feature_df = eval(formula[0], locals())
            elif len(formula) == 2:
                new_feature_df = eval(formula[0], locals(), formula[1])
            calc_back_checker(new_feature_df, set(part_df["MachineIdentifier"].values))
            del part_df
            gc.collect()

            back_col_name = [n for n in new_feature_df.columns if n != "MachineIdentifier"][0]
            new_feature_df = new_feature_df.rename(columns={back_col_name: name})
            new_feature_df = new_feature_df.loc[:, ["MachineIdentifier", name]]
            new_feature_df.sort_values("MachineIdentifier", inplace=True)
            new_feature_df.reset_index(drop=True, inplace=True)

            self.lock.acquire()
            try:
                self.saveNewFeature(new_feature_df)
                print("\r[Group] {:<15} >> multiprocessing : Done {:>3} out of {:>3} latest {:<100}".format(
                    self.__class__.__name__,
                    str(self.check_job_progress()),
                    str(len(needCalculationFeatures)),
                    "\"" + name + "\""), end="")
            finally:
                self.lock.release()

            del new_feature_df
            gc.collect()

        def calc_back_checker(calc_back_df, id_set):
            if len(calc_back_df.columns) != 2:
                print("Calc back dataframe columns length need 2.")
                raise IrregularCalcBackException()
            if "MachineIdentifier" not in calc_back_df.columns:
                print("Calc back dataframe columns need \"MachineIdentifier\".")
                raise IrregularCalcBackException()
            if len(set(calc_back_df["MachineIdentifier"].values) ^ id_set) != 0:
                print("Neither too much nor too little \"MachineIdentifier\" need.")
                raise IrregularCalcBackException()
            if len(calc_back_df["MachineIdentifier"]) != len(id_set):
                print("Calc back dataframe has too much index.")
                raise IrregularCalcBackException()

        featuresFromula = self.getFeaureFromulas()
        featureNameList = list(featuresFromula.keys())
        needCalculationFeatures = {fn: featuresFromula[fn] for fn in featureNameList if not self.isCalculated(fn)}

        if len(needCalculationFeatures) > 0:
            self.check_job_progress(is_init=True)
            print("[Group] {:<15} >> multiprocessing : Done   0 out of {:>3}".format(
                self.__class__.__name__,
                str(len(needCalculationFeatures))), end="")
            Parallel(n_jobs=-1)([delayed(calcFratures)(name, formula) for name, formula in needCalculationFeatures.items()])
            print("")

        return featureNameList

    def isCalculated(self, feature_name):
        '''
        feature_name = {Group_name}_{attribute_name}
        {part}_{group_name}.csvが存在し，かつcsvの一行目にfeature_nameが確認できた場合にTrueを返す．
        '''
        isCalculated = False
        if self.output_path.exists():
            with self.output_path.open() as f:
                columns = f.readline().rstrip("\n\r").split(",")
            if feature_name in columns:
                isCalculated = True

        return isCalculated

    def getFeaureFromulas(self):
        '''
        要求されているfeatureをfeature_nameとfeature_formulaに直してDictで返す．
        return :
            <dict>
            {
            "feature_name1" : [formula1],
            "feature_name2" : [formula2, args],
            "feature_name3" : [formula3, args]
            }
            feature_formula         : "self."calc"(part_df["feature"], arg1, arg2)"
            eval(formula, locals(), args={"arg1": a, "arg2: b"})

            "feature_name"  > 保存先の特徴名 Ex. "feature"_"calc"_a_b etc.
            "calc"          > メソッド名，引数に適応する計算
            "feature"       > inputしたCSV内のcolumn名，（第一引数はpart_df[feature]）
            "args"          > 第二以降の引数を格納した辞書
        '''
        def setFormula(calc, feature, args=None):
            formula = "self." + calc + "(part_df[[\"MachineIdentifier\", \"" + feature
            if args is None:
                formula = formula + "\"]])"
            else:
                formula = formula + "\"]], " + ", ".join([arg for arg in args.keys()]) + ")"
            return formula

        feature_dict = {}

        for feature, calculations in self.features.items():
            for calc, args_list in calculations.items():
                if args_list is None:
                    feature_name = feature + "_" + calc
                    feature_formula = setFormula(calc, feature)
                    feature_dict[feature_name] = [feature_formula]
                elif type(args_list) is list:
                    for args in args_list:
                        feature_name = feature + "_" + calc + "_" + "_".join([arg for arg in args.values()])
                        feature_formula = setFormula(calc, feature, args=args)
                        feature_dict[feature_name] = [feature_formula, args]
                else:
                    raise IrregularArgumentException()
        return feature_dict

    def saveNewFeature(self, new_feature_df):
        '''
        作成した特徴量を受け取りすでに作成している特徴量と合わせてcsvで保存する．
        new_feature_df  <pandas.Dataframe>
          columns = [MachineIdentifier, {feature_name}]
          new_feature_df.sort_values("MachineIdentifier").reset_index(drop=True)をかけてからinputすること
        '''
        if self.output_path.exists():
            new_col = new_feature_df.columns.tolist()[1]
            feature_df = dd.read_csv(self.output_path).compute()
            feature_df[new_col] = new_feature_df[new_col]
        else:
            feature_df = new_feature_df
        feature_df.to_csv(self.output_path, index=False)

    def check_job_progress(self, is_init=False):
        path = Path("tmp")
        path.mkdir(exist_ok=True)
        path = path / "job_num"
        if is_init:
            job_num = 0
            with path.open(mode="w") as f:
                f.write(str(job_num))
        else:
            with path.open(mode="r") as f:
                job_num = int(f.read())
            with path.open(mode="w") as f:
                job_num += 1
                f.write(str(job_num))
        return job_num
